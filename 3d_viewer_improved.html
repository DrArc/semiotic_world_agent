<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SemioCity 3D Viewer (Improved)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#151515; color:#ccc; }
    #status { position: absolute; top: 8px; left: 8px; font: 12px/1.2 sans-serif; z-index: 10; }
    #c { width: 100%; height: 100%; display:block; }
    #controls { position: absolute; top: 8px; right: 8px; z-index: 10; }
    #controls button { background: #333; color: #ccc; border: 1px solid #555; padding: 4px 8px; margin: 2px; cursor: pointer; }
    #controls button:hover { background: #555; }
  </style>
  <!-- Use Three.js from CDN -->
  <script src="https://unpkg.com/three@0.144.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.144.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.144.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
  <div id="status">Ready</div>
  <div id="controls">
    <button onclick="toggleAutoRotate()">Auto Rotate</button>
    <button onclick="resetCamera()">Reset View</button>
  </div>
  <canvas id="c"></canvas>
  <script>
    let renderer, scene, camera, controls, currentModel;
    let autoRotate = false;
    let animationId;

    function ensureRenderer() {
      if (renderer) return;
      
      // Check if THREE is available
      if (typeof THREE === 'undefined') {
        document.getElementById('status').textContent = 'Loading Three.js...';
        setTimeout(ensureRenderer, 100);
        return;
      }
      
      const canvas = document.getElementById('c');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      onResize();
      window.addEventListener('resize', onResize);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x151515);

      // Get actual canvas dimensions for proper aspect ratio
      const canvasRect = canvas.getBoundingClientRect();
      const aspect = canvasRect.width / canvasRect.height;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.01, 1000);
      camera.position.set(3, 2, 3);

      // Check if OrbitControls is available
      if (typeof THREE.OrbitControls !== 'undefined') {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 1.0;
      } else {
        document.getElementById('status').textContent = 'OrbitControls not available';
      }

      // Improved lighting setup
      setupLighting();

      animate();
      document.getElementById('status').textContent = 'Ready';
    }

    function setupLighting() {
      // Clear existing lights
      scene.children = scene.children.filter(child => child.type !== 'Light');
      
      // Ambient light for overall illumination
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);

      // Hemisphere light for natural sky/ground lighting
      const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x362D1D, 0.6);
      scene.add(hemisphereLight);

      // Main directional light (sun)
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -10;
      directionalLight.shadow.camera.right = 10;
      directionalLight.shadow.camera.top = 10;
      directionalLight.shadow.camera.bottom = -10;
      scene.add(directionalLight);

      // Fill light from the opposite side to reduce harsh shadows
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
      fillLight.position.set(-3, 2, -3);
      scene.add(fillLight);

      // Rim light for better edge definition
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
      rimLight.position.set(0, 5, -5);
      scene.add(rimLight);
    }

    function onResize() {
      if (!renderer || !camera) return;
      
      // Get the actual container dimensions
      const container = renderer.domElement.parentElement;
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      if (h === 0 || w === 0) return;
      
      // Update canvas size to match container
      renderer.domElement.style.width = w + 'px';
      renderer.domElement.style.height = h + 'px';
      
      // Update camera aspect ratio
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      
      // Update renderer size
      renderer.setSize(w, h, false);
    }

    function animate() {
      animationId = requestAnimationFrame(animate);
      if (controls) controls.update();
      if (renderer && scene && camera) renderer.render(scene, camera);
    }

    function toggleAutoRotate() {
      if (controls) {
        autoRotate = !autoRotate;
        controls.autoRotate = autoRotate;
        document.getElementById('status').textContent = autoRotate ? 'Auto-rotating...' : 'Ready';
      }
    }

    function resetCamera() {
      if (camera && controls) {
        camera.position.set(3, 2, 3);
        controls.target.set(0, 0, 0);
        controls.update();
      }
    }

    // Utility: frame and center the loaded scene
    function frameObject(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());
      
      // Position camera based on object size
      const distance = size * 2;
      camera.position.set(distance, distance * 0.6, distance);
      camera.lookAt(center);
      
      if (controls) {
        controls.target.copy(center);
        controls.update();
      }
    }

    // Load model function
    window.loadModel = function(url) {
      try {
        ensureRenderer();
        document.getElementById('status').textContent = 'Loading… ' + url;
        
        // Remove existing model
        if (currentModel) {
          scene.remove(currentModel);
        }
        
        const loader = new THREE.GLTFLoader();
        loader.setCrossOrigin('anonymous');
        
        loader.load(
          url,
          function(gltf) {
            currentModel = gltf.scene;
            
            // Enable shadows for all meshes
            currentModel.traverse(function(child) {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            
            scene.add(currentModel);
            frameObject(currentModel);
            
            document.getElementById('status').textContent = 'Model loaded: ' + url.split('/').pop();
            console.log('Model loaded successfully:', url);
          },
          function(progress) {
            const percent = Math.round((progress.loaded / progress.total) * 100);
            document.getElementById('status').textContent = 'Loading… ' + percent + '%';
          },
          function(error) {
            console.error('Error loading model:', error);
            document.getElementById('status').textContent = 'Error loading model: ' + error.message;
          }
        );
      } catch (error) {
        console.error('Error in loadModel:', error);
        document.getElementById('status').textContent = 'Error: ' + error.message;
      }
    };

    // Initialize viewer
    ensureRenderer();
  </script>
</body>
</html>
