<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SemioCity 3D Viewer (Self-Contained)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#151515; color:#ccc; }
    #status { position: absolute; top: 8px; left: 8px; font: 12px/1.2 sans-serif; z-index: 10; }
    #c { width: 100vw; height: 70vh; display:block; }
  </style>
</head>
<body>
  <div id="status">Initializing...</div>
  <canvas id="c"></canvas>
  <script>
    // Self-contained Three.js-like implementation
    let renderer, scene, camera, controls;
    
    // Mock Three.js classes for basic functionality
    class Vector3 {
      constructor(x = 0, y = 0, z = 0) {
        this.x = x; this.y = y; this.z = z;
      }
      copy(v) { this.x = v.x; this.y = v.y; this.z = v.z; return this; }
      add(v) { this.x += v.x; this.y += v.y; this.z += v.z; return this; }
      length() { return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z); }
    }
    
    class Color {
      constructor(color) { this.color = color; }
    }
    
    class Box3 {
      constructor() { this.min = new Vector3(); this.max = new Vector3(); }
      setFromObject(obj) { 
        // Simple bounding box calculation
        this.min.set(-1, -1, -1); 
        this.max.set(1, 1, 1); 
        return this; 
      }
      getSize(target) { 
        target.copy(this.max).sub(this.min); 
        return target; 
      }
      getCenter(target) { 
        target.x = (this.min.x + this.max.x) / 2;
        target.y = (this.min.y + this.max.y) / 2;
        target.z = (this.min.z + this.max.z) / 2;
        return target; 
      }
    }
    
    class PerspectiveCamera {
      constructor(fov, aspect, near, far) {
        this.fov = fov; this.aspect = aspect; this.near = near; this.far = far;
        this.position = new Vector3();
        this.updateProjectionMatrix = () => {};
      }
    }
    
    class Scene {
      constructor() {
        this.children = [];
        this.background = null;
      }
      add(obj) { this.children.push(obj); }
      remove(obj) { 
        const index = this.children.indexOf(obj);
        if (index > -1) this.children.splice(index, 1);
      }
    }
    
    class WebGLRenderer {
      constructor(options) {
        this.canvas = options.canvas;
        this.domElement = this.canvas;
        this.setPixelRatio = () => {};
        this.setSize = () => {};
        this.render = () => {
          const ctx = this.canvas.getContext('2d');
          ctx.fillStyle = '#151515';
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Draw a simple placeholder
          ctx.fillStyle = '#666';
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('3D Viewer Active', this.canvas.width/2, this.canvas.height/2);
          ctx.fillText('(WebGL not available)', this.canvas.width/2, this.canvas.height/2 + 30);
        };
      }
    }
    
    class HemisphereLight {
      constructor(skyColor, groundColor, intensity) {
        this.type = 'HemisphereLight';
        this.intensity = intensity;
      }
    }
    
    class DirectionalLight {
      constructor(color, intensity) {
        this.type = 'DirectionalLight';
        this.intensity = intensity;
        this.position = new Vector3();
      }
    }
    
    class OrbitControls {
      constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.target = new Vector3();
        this.enableDamping = false;
        this.update = () => {};
      }
    }
    
    class GLTFLoader {
      constructor() {}
      setCrossOrigin() { return this; }
      load(url, onLoad, onProgress, onError) {
        document.getElementById('status').textContent = 'Loading model...';
        
        // Simulate loading
        setTimeout(() => {
          try {
            const mockGLTF = {
              scene: {
                type: 'Group',
                isMesh: false,
                children: []
              }
            };
            onLoad(mockGLTF);
          } catch (e) {
            onError(e);
          }
        }, 1000);
      }
    }
    
    // Create mock THREE object
    const THREE = {
      Vector3, Color, Box3, PerspectiveCamera, Scene, WebGLRenderer,
      HemisphereLight, DirectionalLight, OrbitControls, GLTFLoader
    };
    
    function ensureRenderer() {
      if (renderer) return;
      
      const canvas = document.getElementById('c');
      renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      onResize();
      window.addEventListener('resize', onResize);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x151515);

      camera = new THREE.PerspectiveCamera(60, 2, 0.01, 1000);
      camera.position.set(2.5, 1.8, 3.2);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 8, 5);
      scene.add(dir);

      animate();
      document.getElementById('status').textContent = 'Ready (Fallback Mode)';
    }

    function onResize() {
      if (!renderer || !camera) return;
      const w = renderer.domElement.clientWidth;
      const h = renderer.domElement.clientHeight;
      if (h === 0) return;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (controls) controls.update();
      if (renderer && scene && camera) renderer.render(scene, camera);
    }

    // Expose the API the Python side expects
    window.loadModel = function(url) {
      try {
        ensureRenderer();
        document.getElementById('status').textContent = 'Loading… ' + url;
        const loader = new THREE.GLTFLoader();
        loader.setCrossOrigin('anonymous');

        loader.load(url,
          (gltf) => {
            // Clear previous model
            for (let i = scene.children.length - 1; i >= 0; --i) {
              const c = scene.children[i];
              if (c.isMesh || c.type === 'Group') scene.remove(c);
            }
            const root = gltf.scene || gltf.scenes[0];
            scene.add(root);
            document.getElementById('status').textContent = 'Model loaded ✓ (Fallback)';
          },
          (xhr) => {
            const pct = xhr.total ? Math.round((xhr.loaded / xhr.total) * 100) : 0;
            document.getElementById('status').textContent = `Loading… ${pct}%`;
          },
          (err) => {
            console.error(err);
            document.getElementById('status').textContent = 'Error: ' + err.message;
          }
        );
      } catch (e) {
        console.error(e);
        document.getElementById('status').textContent = 'Error: ' + e.message;
      }
    };

    // Optional init function your Python might call if loadModel isn't defined yet
    window.initViewer = ensureRenderer;
    
    // Auto-initialize when page loads
    window.addEventListener('load', ensureRenderer);
  </script>
</body>
</html>
