<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SemioCity 3D Viewer (Simple)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#151515; color:#ccc; }
    #status { position: absolute; top: 8px; left: 8px; font: 12px/1.2 sans-serif; z-index: 10; }
    #c { width: 100%; height: 100%; display:block; }
  </style>
  <!-- Use older, more compatible Three.js version -->
  <script src="https://unpkg.com/three@0.144.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.144.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.144.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
  <div id="status">Ready</div>
  <canvas id="c"></canvas>
  <script>
    let renderer, scene, camera, controls;

    function ensureRenderer() {
      if (renderer) return;
      
      // Check if THREE is available
      if (typeof THREE === 'undefined') {
        document.getElementById('status').textContent = 'Loading Three.js...';
        setTimeout(ensureRenderer, 100);
        return;
      }
      
      const canvas = document.getElementById('c');
      renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      onResize();
      window.addEventListener('resize', onResize);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x151515);

      // Get actual canvas dimensions for proper aspect ratio
      const canvasRect = canvas.getBoundingClientRect();
      const aspect = canvasRect.width / canvasRect.height;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.01, 1000);
      camera.position.set(2.5, 1.8, 3.2);

      // Check if OrbitControls is available
      if (typeof THREE.OrbitControls !== 'undefined') {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
      } else {
        document.getElementById('status').textContent = 'OrbitControls not available';
      }

      const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 8, 5);
      scene.add(dir);

      animate();
      document.getElementById('status').textContent = 'Ready';
    }

    function onResize() {
      if (!renderer || !camera) return;
      
      // Get the actual container dimensions
      const container = renderer.domElement.parentElement;
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      if (h === 0 || w === 0) return;
      
      // Update canvas size to match container
      renderer.domElement.style.width = w + 'px';
      renderer.domElement.style.height = h + 'px';
      
      // Update camera aspect ratio
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      
      // Update renderer size
      renderer.setSize(w, h, false);
      
      console.log('Resized to:', w, 'x', h, 'aspect:', camera.aspect);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (controls) controls.update();
      if (renderer && scene && camera) renderer.render(scene, camera);
    }

    // Utility: frame and center the loaded scene
    function frameObject(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());
      
      if (controls && size > 0) {
        // Set controls target to object center
        controls.target.copy(center);
        
        // Calculate optimal camera distance based on object size and FOV
        const fov = camera.fov * (Math.PI / 180); // Convert to radians
        const distance = (size * 1.5) / Math.tan(fov / 2);
        
        // Position camera at a good angle to view the object
        camera.position.copy(center);
        camera.position.add(new THREE.Vector3(distance * 0.7, distance * 0.7, distance * 0.7));
        
        // Update camera settings
        camera.near = Math.max(0.001, size / 1000);
        camera.far = size * 100;
        camera.updateProjectionMatrix();
        
        // Update controls
        controls.update();
        
        console.log('Framed object - size:', size, 'center:', center, 'distance:', distance);
      }
    }

    // Expose the API the Python side expects
    window.loadModel = function(url) {
      try {
        ensureRenderer();
        
        // Check if GLTFLoader is available
        if (typeof THREE.GLTFLoader === 'undefined') {
          document.getElementById('status').textContent = 'GLTFLoader not available';
          return;
        }
        
        document.getElementById('status').textContent = 'Loading… ' + url;
        const loader = new THREE.GLTFLoader();
        // Allow file:// and cross-origin loads
        loader.setCrossOrigin('anonymous');

        loader.load(url,
          (gltf) => {
            // Clear previous model
            for (let i = scene.children.length - 1; i >= 0; --i) {
              const c = scene.children[i];
              if (c.isMesh || c.type === 'Group') scene.remove(c);
            }
            const root = gltf.scene || gltf.scenes[0];
            scene.add(root);
            frameObject(root);
            
            // Ensure proper viewport sizing after model loads
            setTimeout(() => {
              onResize();
              if (controls) controls.update();
            }, 100);
            
            document.getElementById('status').textContent = 'Model loaded ✓';
          },
          (xhr) => {
            const pct = xhr.total ? Math.round((xhr.loaded / xhr.total) * 100) : 0;
            document.getElementById('status').textContent = `Loading… ${pct}%`;
          },
          (err) => {
            console.error(err);
            document.getElementById('status').textContent = 'Error: ' + err.message;
          }
        );
      } catch (e) {
        console.error(e);
        document.getElementById('status').textContent = 'Error: ' + e.message;
      }
    };

    // Optional init function your Python might call if loadModel isn't defined yet
    window.initViewer = ensureRenderer;
    
    // Auto-initialize when page loads
    window.addEventListener('load', ensureRenderer);
  </script>
</body>
</html>